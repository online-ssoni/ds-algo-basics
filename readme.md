# Data structures and algorithms

- [x]  **Analysis of algorithms**
- [ ]  **Mathematics**
    - [x]  Count digits
    - [x]  Palindrome numbers
    - [x]  Trailing zeros in factorial
    - [x]  GCD or HCF
    - [x]  LCM
    - [x]  Check for prime
    - [x]  Prime factors
    - [x]  All divisors of a number
    - [x]  Sieve of Erathosthenas
    - [x]  Computing power
    - [ ]  Iterative power
    - [ ]  Absolute value
    - [x]  Convert celcuis to farenheit
    - [x]  Quadratic equation roots
    - [x]  Factorial of a number
    - [ ]  Digits in factorial
    - [ ]  Primality test
    - [ ]  Exactly 3 divisors
    - [ ]  GP term
    - [ ]  Addition under modulo
    - [ ]  Multiplication under modulo
    - [ ]  Modular multiplicative inverse
- [ ]  **Bit-Magic**
    - [ ]  Complete playlist: https://www.youtube.com/watch?v=v62IKeJtj0k&list=PL-Jc9J83PIiFJRioti3ZV7QabwoJK6eKe
    - [ ]  Bitwise operators in java
    - [ ]  Bitwise operators in python
    - [ ]  Binary representation of negative numbers
    - [ ]  Check if Kth bit is set or not
    - [ ]  Count set bits
    - [ ]  Power of two
    - [ ]  One odd occuring
    - [ ]  Two odd occuring
    - [ ]  Power set using bitwise
    - [ ]  Find first set bit
    - [ ]  count total set bits
    - [ ]  Power of 2
    - [ ]  Rightmost different bit
    - [ ]  Bit difference
    - [ ]  Swap all odd and even bits
    - [ ]  Longest consecutive 1’s
    - [ ]  Maximum AND value
    - [ ]  Number is Sparse or not
    - [ ]  Binary to gray code equivalent
    - [ ]  Gray to binary equivalent
- [ ]  **Recursion**
    - [ ]  Print N to 1
    - [ ]  Print 1 to N
    - [ ]  Tail recursion
    - [ ]  Writing base cases in recursion
    - [ ]  Natural number sum
    - [ ]  Palindrome check
    - [ ]  Sum of digits
    - [ ]  Rope cutting problem
    - [ ]  Generate subsets
    - [ ]  Tower of hanoi
    - [ ]  Josephus problem
    - [ ]  Subset sum problem
    - [ ]  Printing all permutations
    - [ ]  Power of numbers
    - [ ]  Power using recursion
    - [ ]  Fibonacci
    - [ ]  Power set using recursion
    - [ ]  Digital root
    - [ ]  Lucky numbers
    - [ ]  Possible words from phone digits
- [ ]  **Arrays**
    - [ ]  Largest element in an array
    - [ ]  Second largest element in an array
    - [ ]  Check if array is sorted
    - [ ]  Reverse and array
    - [ ]  Remove duplicates from sorted array
    - [ ]  Move zeros to end
    - [ ]  Left rotate an array by one
    - [ ]  Left rotate array by D places
    - [ ]  Leaders in array
    - [ ]  Maximum difference problem with order
    - [ ]  Frequencies in sorted array
    - [ ]  Stock buy and sell
    - [ ]  Trapping rain water
    - [ ]  Maximum consecutive 1s
    - [ ]  Maximum subarray sum
    - [ ]  Longest even odd sub array
    - [ ]  Maximum circular sum subarray
    - [ ]  Majority element
    - [ ]  Minimum consecutive flips
    - [ ]  Sliding window technique
    - [ ]  Subarray with given sum
    - [ ]  Prefix sum
    - [ ]  Equillibrium point
    - [ ]  Maximum appearing element
    - [ ]  Array insert at end
    - [ ]  Array insert at index
    - [ ]  Maximum index
    - [ ]  Max and second max
    - [ ]  Mean and median of an array
    - [ ]  Check if array is sorted and rotated
    - [ ]  Reverse array in groups
    - [ ]  rearrange array with O(1) extra space
    - [ ]  Rotate array
    - [ ]  Leaders in array
    - [ ]  Rearrange array alternatively
    - [ ]  Smallest positive missing number
    - [ ]  Frequencies of limited range array elements
    - [ ]  Kadane’s algorithm
    - [ ]  Max circular subarray sum
    - [ ]  Minimum adjacent difference in circular array
    - [ ]  Wave array
    - [ ]  Maximum occured integer
    - [ ]  Who has the majority?
    - [ ]  Fraction trouble
    - [ ]  Print pattern
    - [ ]  Longest subarrays of evens and odds
    - [ ]  Betting game
    - [ ]  Equillibrium point
    - [ ]  Strongest neighbour
- [ ]  **Searching**
    - [ ]  Binary search - iterative
    - [ ]  Binary search - recursive
    - [ ]  index of first occurance in sorted array
    - [ ]  index of last occurance in sorted array
    - [ ]  count occurance in sorted array
    - [ ]  Count 1s in sorted binary array
    - [ ]  Square root
    - [ ]  Search in infinite sized array
    - [ ]  Search in sorted and rotated array
    - [ ]  Find a peak element
    - [ ]  Two pointers approach
    - [ ]  Triplet in sorted array
    - [ ]  Median of two sorted array
    - [ ]  Repeating elements
    - [ ]  Allocate minimum pages
    - [ ]  Floor in sorted array
    - [ ]  Majority element
    - [ ]  Left index
    - [ ]  count more than n/k occurances
    - [ ]  Count 1’s in binary array
    - [ ]  Smallest positive missing number
    - [ ]  Square root of a number
    - [ ]  Minimum number in a sorted rotated array
    - [ ]  Peak element
    - [ ]  Roof top
    - [ ]  Subarray with given sum
    - [ ]  Median of two sorted arrays
    - [ ]  Count only repeated
    - [ ]  Two repeated elements
    - [ ]  Allocate minimum number of pages
    - [ ]  Maximum water between two buildings
- [ ]  **Sorting**
    - [ ]  Stability in Sorting Algorithm
    - [ ]  Bubble Sort
    - [ ]  Selection Sort
    - [ ]  Insertion Sort
    - [ ]  Merge sort
    - [ ]  Intersection of two sorted arrays
    - [ ]  Union of two sorted arrays
    - [ ]  Count inversions in Array
    - [ ]  Naive partition
    - [ ]  Lomuto Partition
    - [ ]  Hoare partition
    - [ ]  Quick Sort Introduction
    - [ ]  QuickSort using Lomuto Partition
    - [ ]  QuickSort using Hoare Partition
    - [ ]  Choice of pivot and worst case of quick sort
    - [ ]  Tail call elimination in QuickSort
    - [ ]  Kth Smallest Element
    - [ ]  Minimum Difference in an Array
    - [ ]  Chocolate Distribution Problem
    - [ ]  Sort an Array with two types of elements
    - [ ]  Sort an array with three types of elements
    - [ ]  Merge overlapping intervals
    - [ ]  Meeting the maximum guests
    - [ ]  Cycle Sort
    - [ ]  Heap Sort
    - [ ]  Counting Sort
    - [ ]  Radix Sort
    - [ ]  Bucket Sort
    - [ ]  Merge Without Extra Space
    - [ ]  Merge three sorted arrays
    - [ ]  Find triplets with zero sum
    - [ ]  Count Inversions
    - [ ]  Three way partitioning
    - [ ]  Kth smallest element
    - [ ]  Minimum Difference in an Array
    - [ ]  Binary Array Sorting
    - [ ]  Closet 0s 1s and 2s
    - [ ]  Minimum Platforms
    - [ ]  Counting Sort
    - [ ]  Count the number of possible triangles
    - [ ]  Sort by Absolute Difference
    - [ ]  Triplet Sum in Array
    - [ ]  Number of pairs
    - [ ]  Closer to sort
- [ ]  **Matrix**
    - [ ]  Matrix in Snake Pattern
    - [ ]  Matrix Boundary Traversal
    - [ ]  Transpose of a Matrix
    - [ ]  Rotate Matrix Anti-clockwise by 90
    - [ ]  Spiral Traversal of Matrix
    - [ ]  Search in Row-wise and Column-wise sorted matrix
    - [ ]  Median of a Row Wise Sorted Matrix Java
    - [ ]  Adding two matrices
    - [ ]  Multiply the matrices
    - [ ]  Print Matrix in snake Pattern
    - [ ]  Boundary traversal of matrix
    - [ ]  Transpose of Matrix
    - [ ]  Rotate by 90 degree
    - [ ]  Spirally traversing a matrix
    - [ ]  Search in a row-column sorted Matrix
    - [ ]  Determinant of a Matrix
    - [ ]  Sum of upper and lower triangles
    - [ ]  Exchange matrix columns
    - [ ]  Reversing the columns of a Matrix
    - [ ]  Interchanging the rows of a Matrix
    - [ ]  Boolean Matrix
    - [ ]  Make Matrix Beautiful
- [ ]  **Hashing**
    - [ ]  Introduction to Hashing & Hashing Application
    - [ ]  Direct Address Table
    - [ ]  Hashing Functions
    - [ ]  Collision Handling
    - [ ]  Chaining
    - [ ]  Implementation of Chaining
    - [ ]  Open Addressing
    - [ ]  Double Hashing
    - [ ]  Implementation of Open Addressing
    - [ ]  Chaining vs Open Addressing
    - [ ]  HashSet in Java
    - [ ]  HashMap in Java
    - [ ]  Count Distinct Elements
    - [ ]  Frequencies of array elements
    - [ ]  Intersection of two unsorted arrays
    - [ ]  Union of two unsorted arrays
    - [ ]  Pair with given sum in unsorted array
    - [ ]  Subarray with zero sum
    - [ ]  Subarray with given Sum
    - [ ]  Longest subarray with given sum
    - [ ]  Longest subarray with equal number of 0's and 1's
    - [ ]  Longest common span with same sum in binary arrays
    - [ ]  Longest Consecutive Subsequence
    - [ ]  Count Distinct Elements In Every Window
    - [ ]  More than n/k Occurences
    - [ ]  More than n/k Occurences (O(nk) solution)
    - [ ]  Linear Probing in Hashing
    - [ ]  Separate chaining in Hashing
    - [ ]  Quadratic Probing in Hashing
    - [ ]  Check if two arrays are equal or not
    - [ ]  Hashing for pair - 1
    - [ ]  Hashing for pair - 2
    - [ ]  Count Non-Repeated Elements
    - [ ]  Print Non-Repeated Elements
    - [ ]  Sorting Elements of an Array by Frequency
    - [ ]  Sort an array according to the other
    - [ ]  First Repeating Element
    - [ ]  Intersection of two arrays
    - [ ]  Union of two arrays
    - [ ]  Positive Negative Pair
    - [ ]  Subarray with 0 sum
    - [ ]  Zero Sum Subarrays
    - [ ]  Subarray range with given sum
    - [ ]  Subarrays with equal 1s and 0s
    - [ ]  Longest consecutive subsequence
    - [ ]  Numbers containing 1, 2 and 3
    - [ ]  Winner of an election
    - [ ]  Account Merge
- [ ]  **Strings**
    - [ ]  Palindrome Check
    - [ ]  Check if a String is Subsequence of Other
    - [ ]  Check for Anagram
    - [ ]  Leftmost Repeating Character
    - [ ]  Leftmost Non-repeating Element
    - [ ]  Reverse words in a string
    - [ ]  Overview of Pattern Searching
    - [ ]  Naive Pattern Searching
    - [ ]  Improved Naive Pattern Searching for Distinct
    - [ ]  Rabin Karp Algorithm
    - [ ]  KMP Algorithm (Part 1 : Constructing LPS Array)
    - [ ]  KMP Algorithm (Part 2 : Complete Algorithm)
    - [ ]  Check if Strings are Rotations
    - [ ]  Anagram Search
    - [ ]  Lexicographic Rank of a String
    - [ ]  Longest Substring with Distinct Characters
    - [ ]  Binary String
    - [ ]  Implement strstr
    - [ ]  Check if strings are rotations of each other or not
    - [ ]  Isomorphic Strings
    - [ ]  Check if a String is Subsequence of Other
    - [ ]  Maximum Occurring Character
    - [ ]  Case-specific Sorting of Strings
    - [ ]  Anagram
    - [ ]  Check if a string is Isogram or not
    - [ ]  Repeating Character - First Appearance Leftmost
    - [ ]  Non Repeating Character
    - [ ]  Minimum indexed character
    - [ ]  The Modified String
    - [ ]  Reverse words in a given string
    - [ ]  Remove common characters and concatenate
    - [ ]  Sum of numbers in string
    - [ ]  Naive Pattern Search
    - [ ]  Nth number made of prime digits
    - [ ]  Rabin Karp - Pattern Searching
    - [ ]  Keypad typing
    - [ ]  Pattern Search KMP
    - [ ]  Pattern Search
    - [ ]  Check if string is rotated by two places
    - [ ]  Panagram Checking
    - [ ]  Lexicographic Rank Of A String
    - [ ]  Smallest window in a string containing all the characters of another string
- [ ]  **Linked List**
    - [ ]  Introduction to Linked List
    - [ ]  Traversing a Linked List in Java
    - [ ]  Recursive Traversal of Singly Linked List
    - [ ]  Insert at Begin of Singly Linked List
    - [ ]  Insert at the end of Singly Linked List
    - [ ]  Insert at given position in Singly Linked List
    - [ ]  Delete First Node of Singly Linked List
    - [ ]  Delete Last of Singly Linked List
    - [ ]  Search in a Linked List (Iterative and Recursive)
    - [ ]  Doubly Linked List in Java
    - [ ]  Singly Vs Doubly Linked List (Advantages & Disadvantages)
    - [ ]  Insert at Begin of Doubly Linked List
    - [ ]  Insert at End Doubly Linked List
    - [ ]  Reverse a Doubly Linked List
    - [ ]  Delete Head of a Doubly Linked List
    - [ ]  Delete Last of a Doubly Linked List
    - [ ]  Circular Linked List in Java
    - [ ]  Circular Linked List (Advantages & Disadvantages)
    - [ ]  Circular Linked List Traversal in Java
    - [ ]  Insert at Begin of Circular Linked List
    - [ ]  Insert at the end of Circular Linked List
    - [ ]  Delete Head of Circular Linked List
    - [ ]  Delete Kth of a Circular Linked List
    - [ ]  Circular Doubly Linked List
    - [ ]  Sorted Insert in a Singly Linked List
    - [ ]  Middle of linked list
    - [ ]  Nth Node from end of Linked List
    - [ ]  Reverse a linked list iterative
    - [ ]  Recursive reverse a linked list (Part 1)
    - [ ]  Recursive reverse a linked list (Part 2)
    - [ ]  Remove duplicates from a sorted Singly Linked List
    - [ ]  Reverse a linked list in groups of size k
    - [ ]  Detect loop
    - [ ]  Detect loop using floyd cycle detection
    - [ ]  Detect and remove loop in linked list
    - [ ]  Delete node with only pointer given to it
    - [ ]  Segregate Even and Odd Nodes in Java
    - [ ]  Intersection Point of two linked list
    - [ ]  Pairwise Swap Nodes of linked list in Java
    - [ ]  Clone a linked list with Random Pointer in Java
    - [ ]  LRU Cache Design
    - [ ]  Merge two sorted linked lists
    - [ ]  Palindrome Linked List
    - [ ]  Count nodes of linked list
    - [ ]  Find length of Loop
    - [ ]  Linked List Insertion
    - [ ]  Doubly linked list Insertion at given position
    - [ ]  Reverse a linked list
    - [ ]  Add two numbers represented by linked lists
    - [ ]  Swap Kth nodes from ends
    - [ ]  Delete without head pointer
    - [ ]  Remove duplicate element from sorted Linked List
    - [ ]  Identical Linked Lists
    - [ ]  Insert in Middle of Linked List
    - [ ]  Merge Sort on Doubly Linked List
    - [ ]  Nth node from end of linked list
    - [ ]  Given a linked list of 0s, 1s and 2s, sort it
    - [ ]  Remove duplicates from an unsorted linked list
    - [ ]  Rotate a Linked List
    - [ ]  Detect Loop in linked list
    - [ ]  Remove loop in Linked List
    - [ ]  Add two numbers represented by Linked List
    - [ ]  Intersection Point in Y Shaped Linked Lists
    - [ ]  Pairwise swap of nodes in LinkedList
    - [ ]  Clone a linked list with next and random pointer
    - [ ]  LRU Cache
    - [ ]  Merge two sorted linked lists
    - [ ]  Merge K sorted linked lists
    - [ ]  Merge Sort for Linked List
    - [ ]  Check if Linked List is Palindrome
- [ ]  **Stack**
    - [ ]  Stack Data Structure
    - [ ]  Array Implementation of Stack in Java
    - [ ]  Linked List Implementation of Stack in Java
    - [ ]  Stack in Java Collections
    - [ ]  Balanced Parenthesis
    - [ ]  Implement two Stacks in an Array
    - [ ]  Implement K Stacks in an Array in Java
    - [ ]  Stock span problem
    - [ ]  Previous Greater Element
    - [ ]  Next Greater Element
    - [ ]  Largest Rectangular Area in a Histogram (Part 1)
    - [ ]  Largest Rectangular Area in a Histogram (Part 2)
    - [ ]  Largest Rectangle with all 1's
    - [ ]  Stack with getMin() in O(1)
    - [ ]  Design a Stack with getMin() in O(1) Space
    - [ ]  Infix, Prefix and Postfix Introduction
    - [ ]  Infix to Postfix (Simple sol.)
    - [ ]  Infix to Postfix (Efficient Solution)
    - [ ]  Evaluation of Postfix
    - [ ]  Infix to Prefix (Simple Solution)
    - [ ]  Infix to Prefix (Efficient Solution)
    - [ ]  Evaluation of Prefix
    - [ ]  Implement stack using array
    - [ ]  Implement Stack using Linked List
    - [ ]  Operations on Stack
    - [ ]  Delete middle element of a stack
    - [ ]  Parenthesis Checker
    - [ ]  Removing consecutive duplicates
    - [ ]  Removing consecutive duplicates - 2
    - [ ]  Implement two stacks in an array
    - [ ]  Stock span problem
    - [ ]  Next Greater Element
    - [ ]  Get min at pop
    - [ ]  Maximum Rectangular Area in a Histogram
    - [ ]  The Celebrity Problem
    - [ ]  Infix to Postfix
    - [ ]  Evaluation of Postfix Expression
    - [ ]  Maximum of minimum for every window size
- [ ]  **Queue**
    - [ ]  Queue Data Structure
    - [ ]  Implementation of Queue using Array
    - [ ]  Implementation of Queue using Linked List
    - [ ]  Queue in Java
    - [ ]  Implementing stack using queue
    - [ ]  Reversing a Queue
    - [ ]  Generate numbers with given digits
    - [ ]  Implement Queue using array
    - [ ]  Operations on Queue
    - [ ]  Implement Queue using Linked List
    - [ ]  Stack using two queues
    - [ ]  Queue using two Stacks
    - [ ]  Queue Reversal
    - [ ]  Reverse First K elements of Queue
    - [ ]  Generate Binary Numbers
    - [ ]  Circular tour
- [ ]  **Dequeue**
    - [ ]  Deque Data Structure
    - [ ]  Array Implementation of Deque
    - [ ]  Deque in Java
    - [ ]  ArrayDeque in Java
    - [ ]  Design a Data Structure with Min and Max operations
    - [ ]  Maximums of all subarrays of size k
    - [ ]  First Circular Tour
    - [ ]  Insertion in deque
    - [ ]  Deque deletion
    - [ ]  Deque Traversal
    - [ ]  Deque Implementations
    - [ ]  Rotate Deque By K
    - [ ]  Maximum of all subarrays of size k
- [ ]  **Tree**
    - [ ]  Tree Data Structure
    - [ ]  Application of Tree
    - [ ]  Binary Tree
    - [ ]  Tree Traversal
    - [ ]  Implementation of Inorder Traversal
    - [ ]  Implementation of Preorder Traversal
    - [ ]  Implementation of Postorder Traversal
    - [ ]  Height of Binary Tree
    - [ ]  Print Nodes at K distance
    - [ ]  Level Order Traversal
    - [ ]  Level Order Traversal Line by Line (Part 1)
    - [ ]  Level Order Traversal Line by Line (Part 2)
    - [ ]  Size of Binary Tree
    - [ ]  Maximum in Binary Tree
    - [ ]  Print Left View of Binary Tree
    - [ ]  Children Sum Property
    - [ ]  Check for Balanced Binary Tree
    - [ ]  Maximum Width of Binary Tree
    - [ ]  Convert Binary Tree to Doubly Linked List
    - [ ]  Construct Binary Tree from Inorder and Preorder
    - [ ]  Tree Traversal in Spiral Form
    - [ ]  Diameter of a Binary Tree
    - [ ]  LCA of Binary Tree (Part 1)
    - [ ]  LCA of Binary Tree (Part 2)
    - [ ]  Burn a Binary Tree from a Leaf
    - [ ]  Count nodes in a Complete Binary Tree
    - [ ]  Serialize and Deserialize a Binary Tree
    - [ ]  Iterative Inorder Traversal
    - [ ]  Iterative Preorder Traversal (Simple)
    - [ ]  Iterative Preorder Traversal (Space Optimized)
    - [ ]  Preorder Traversal
    - [ ]  Inorder Traversal
    - [ ]  Postorder Traversal
    - [ ]  Height of Binary Tree
    - [ ]  Node at distance
    - [ ]  Level order traversal
    - [ ]  Level order traversal Line by Line
    - [ ]  ZigZag Tree Traversal
    - [ ]  Left View of Binary Tree
    - [ ]  Right View of Binary Tree
    - [ ]  Children Sum Parent
    - [ ]  Mirror Tree
    - [ ]  Check for Balanced Tree
    - [ ]  Check if subtree
    - [ ]  Maximum Width of Tree
    - [ ]  Foldable Binary Tree
    - [ ]  Vertical Width of a Binary Tree
    - [ ]  Binary Tree to DLL
    - [ ]  Binary Tree to CDLL
    - [ ]  Tree from Postorder and Inorder
    - [ ]  Make Binary Tree From Linked List
    - [ ]  Construct Binary Tree from Parent Array
    - [ ]  Level order traversal in spiral form
    - [ ]  Connect Nodes at Same Level
    - [ ]  Diameter of a Binary Tree
    - [ ]  Maximum path sum from any node
    - [ ]  Lowest Common Ancestor in a Binary Tree
    - [ ]  Maximum difference between node and its ancestor
    - [ ]  Count Number of SubTrees having given Sum
    - [ ]  Determine if Two Trees are Identical
    - [ ]  Serialize and Deserialize a Binary Tree
    - [ ]  Maximum sum of Non-adjacent nodes
- [ ]  **Binary Search Tree**
    - [ ]  Binary Search Tree(Background)
    - [ ]  Binary Search Tree(Introduction)
    - [ ]  Search in BST (Introduction)
    - [ ]  Search in BST Java
    - [ ]  Insert in BST
    - [ ]  Insert in BST Java
    - [ ]  Deletion in BST
    - [ ]  BST Deletion in Java
    - [ ]  Floor in BST
    - [ ]  Floor in BST Java
    - [ ]  Ceil in BST
    - [ ]  Self Balancing BST
    - [ ]  AVL Tree
    - [ ]  Red Black Tree
    - [ ]  Applications of BST
    - [ ]  Ceiling on left side in an array
    - [ ]  Find Kth Smallest in BST
    - [ ]  Check for BST
    - [ ]  Fix BST with Two Nodes Swapped
    - [ ]  Pair Sum with given BST
    - [ ]  Vertical Sum in a Binary Tree
    - [ ]  Vertical Traversal of Binary Tree
    - [ ]  Top View of Binary Tree
    - [ ]  Bottom View of Binary Tree
    - [ ]  Search a node in BST
    - [ ]  Minimum element in BST
    - [ ]  Insert a node in a BST
    - [ ]  Inorder traversal of a BST
    - [ ]  Delete a node from BST
    - [ ]  Floor in BST
    - [ ]  Ceil in BST
    - [ ]  Smaller on Right
    - [ ]  Find the Closest Element in BST
    - [ ]  Check for BST
    - [ ]  Merge two BST 's
    - [ ]  Fixing Two nodes of a BST
    - [ ]  Find Common Nodes in two BSTs
    - [ ]  Pair Sum in BST
    - [ ]  Print BST elements in given range
    - [ ]  Vertical Traversal of Binary Tree
    - [ ]  Levelorder traversal of a BST
    - [ ]  Convert Level Order Traversal to BST
    - [ ]  Top View of Binary Tree
    - [ ]  Preorder to PostOrder
    - [ ]  Bottom View of Binary Tree
    - [ ]  Lowest Common Ancestor in a BST
    - [ ]  Count BST nodes that lie in a given range
- [ ]  **Heap**
    - [ ]  Binary Heap Introduction
    - [ ]  Binary Heap Implementation
    - [ ]  Binary Heap Insert
    - [ ]  Binary Heap (Heapify and Extract)
    - [ ]  Binary Heap (Decrease Key, Delete and Build Heap)
    - [ ]  Heap Sort
    - [ ]  PriorityQueue in Java
    - [ ]  Sort K-Sorted Array
    - [ ]  Buy Maximum Items with Given Sum
    - [ ]  K Largest Elements
    - [ ]  K Closest Elements
    - [ ]  Merge K Sorted Arrays
    - [ ]  Median of a Stream
    - [ ]  Binary Heap Operations
    - [ ]  Heap Sort
    - [ ]  Kth largest element
    - [ ]  Nearly sorted
    - [ ]  K Most occurring elements
    - [ ]  Minimum Cost of ropes
    - [ ]  K largest elements
    - [ ]  Kth smallest element
    - [ ]  Rearrange characters
    - [ ]  Merge k Sorted Arrays
    - [ ]  Find median in a stream
    - [ ]  Kth largest element in a stream
- [ ]  **Graph**
    - [ ]  Introduction to Graph
    - [ ]  Graph Representation (Adjacency Matrix)
    - [ ]  Graph Representation (Adjacency List)
    - [ ]  Adjacency List implementation in Java
    - [ ]  Adjacency Matrix and List Comparison
    - [ ]  Breadth First Search
    - [ ]  Applications of BFS
    - [ ]  Depth First Search
    - [ ]  Applications of DFS
    - [ ]  Shortest Path in an Unweighted Graph
    - [ ]  Detect Cycle in Undirected Graph
    - [ ]  Detect Cycle in a Directed Graph (Part 1)
    - [ ]  Topological Sorting (Kahn's BFS Based Algortihm)
    - [ ]  Detect Cycle in a Directed Graph (Part 2)
    - [ ]  Topological Sorting (DFS Based Algorithm)
    - [ ]  Shortest Path in DAG
    - [ ]  Prim's Algorithm/Minimum Spanning Tree
    - [ ]  Implementation of Prim's Algorithm Java
    - [ ]  Dijkstra's Shortest Path Algorithm
    - [ ]  Implementation of Dijkstra's Algorithm Java
    - [ ]  Kosaraju's Algorithm
    - [ ]  Bellman Ford Shortest Path Algorithm
    - [ ]  Articulation Point
    - [ ]  Bridges in Graph
    - [ ]  Tarjans Algorithm
    - [ ]  Kruskal's Algorithm
    - [ ]  Print adjacency list
    - [ ]  BFS of graph
    - [ ]  Distance of nearest cell having 1
    - [ ]  DFS of Graph
    - [ ]  Rotten Oranges
    - [ ]  Steps by Knight
    - [ ]  Find the number of islands
    - [ ]  Find whether path exist
    - [ ]  Level of Nodes
    - [ ]  Possible paths between 2 vertices
    - [ ]  X Total Shapes
    - [ ]  Detect cycle in an undirected graph
    - [ ]  Topological sort
    - [ ]  Minimum Swaps to Sort
    - [ ]  Mother Vertex
    - [ ]  Detect cycle in a directed graph
    - [ ]  Minimum Cost Path
    - [ ]  Unit Area of largest region of 1's
    - [ ]  Minimum Spanning Tree
    - [ ]  Implementing Dijkstra Algorithm
    - [ ]  Strongly Connected Components (Kosaraju's Algo)
    - [ ]  Articulation Point
    - [ ]  Bridge edge in a graph
    - [ ]  Strongly connected component (Tarjans's Algo)
- [ ]  **Greedy**
    - [ ]  Introduction to Greedy Algorithms
    - [ ]  Activity Selection Problem
    - [ ]  Activity Selection Solution in Java
    - [ ]  Fractional Knapsack Problem
    - [ ]  Fractional Knapsack in Java
    - [ ]  Job Sequencing Problem
    - [ ]  Huffman Coding (introduction)
    - [ ]  Huffman Algorithms
    - [ ]  Java Implementation of Huffman coding
    - [ ]  Activity Selection
    - [ ]  N meetings in one room
    - [ ]  Fractional Knapsack
    - [ ]  Job Sequencing Problem
    - [ ]  Largest number with given sum
    - [ ]  Huffman Decoding
- [ ]  **Back tracking**
    - [ ]  Concepts of Backtracking
    - [ ]  Rat In a Maze
    - [ ]  N Queen Problem
    - [ ]  Sudoku Problem
    - [ ]  Combination Sum
    - [ ]  M-Coloring Problem
    - [ ]  Rat Maze With Multiple Jumps
    - [ ]  Largest number in K swaps
    - [ ]  Unique Subsets
    - [ ]  Solve the Sudoku
    - [ ]  Black and White
- [ ]  **Dynamic programming**
    - [ ]  Introduction to DP
    - [ ]  Dynamic Programming Memoization
    - [ ]  Dynamic Programming Tabulation
    - [ ]  Longest Common Subsequence
    - [ ]  Variation of LCS
    - [ ]  Coin Change (Naive Recursive Solution)
    - [ ]  Coin Change (DP Solution)
    - [ ]  Edit Distance Problem
    - [ ]  Edit Distance Problem DP solution
    - [ ]  Longest Increasing Subsequence Problem
    - [ ]  Longest Increasing Subsequence in O(nlogn)
    - [ ]  Variation of LIS
    - [ ]  Maximum Cuts
    - [ ]  Minimum coins to make a value
    - [ ]  Minimum Jumps to reach at end
    - [ ]  0-1 knapsack problem
    - [ ]  0-1 knapsack problem DP Solution
    - [ ]  Optimal Strategy for a Game
    - [ ]  Egg Dropping Puzzle
    - [ ]  Count BSTs with n keys
    - [ ]  Maximum sum with no two consecutive
    - [ ]  Subset Sum Problem (Recursive Solution) (Medium)
    - [ ]  Subset Sum Problem (DP Solution) (Medium)
    - [ ]  Matrix Chain Multiplication
    - [ ]  Matrix Chain Multiplication (DP Solution) (Hard)
    - [ ]  Palindrome Partitioning
    - [ ]  Allocate Minimum Pages (Naive Method)
    - [ ]  Allocate Minimum Pages (DP Solution) (Hard)
    - [ ]  Fibonacci Numbers - Bottom Up DP
    - [ ]  Ways to write n as sum
    - [ ]  Kadane's Algorithm
    - [ ]  Fibonacci Numbers - Top Down DP
    - [ ]  Count ways to reach the n'th stair
    - [ ]  Count ways to N'th Stair(Order does not matter)
    - [ ]  Print first n Fibonacci Numbers
    - [ ]  Nth catalan number
    - [ ]  Longest Common Subsequence
    - [ ]  Coin Change - Minimum number of coins
    - [ ]  Coin Change - Number of ways
    - [ ]  Minimum number of jumps
    - [ ]  Count number of hops
    - [ ]  Longest Increasing Subsequence
    - [ ]  Shortest Common Supersequence
    - [ ]  Number of Unique Paths
    - [ ]  Maximize The Cut Segments
    - [ ]  Sum of all substrings of a number
    - [ ]  0 - 1 Knapsack Problem
    - [ ]  nCr
    - [ ]  Optimal Strategy For A Game
    - [ ]  Reach a given score
    - [ ]  Egg Dropping Puzzle
    - [ ]  Unique BST's
    - [ ]  Stickler Thief
    - [ ]  Max sum subarray by removing at most one element
    - [ ]  Equal Sum Partition
- [ ]  **Trie**
    - [ ]  Trie Data Structure (Introduction)
    - [ ]  Trie (Representation, Search and Insert)
    - [ ]  Trie Delete
    - [ ]  Count Distinct Rows in a Binary Matrix
    - [ ]  Trie | (Insert and Search)
    - [ ]  Search Query for Strings
    - [ ]  Camel Case
    - [ ]  Renaming Cities
    - [ ]  Most frequent word in an array of strings
    - [ ]  Contiguous Elements XOR
- [ ]  **Segment and Binary indexed trees**
    - [ ]  Segment Tree (Introduction)
    - [ ]  Constructing Segment Tree
    - [ ]  Range Query on Segment Tree
    - [ ]  Update Query on Segment Tree
    - [ ]  Binary Indexed Tree (Introduction)
    - [ ]  Binary Indexed Tree (An Example Problem)
    - [ ]  Binary Indexed Tree (Prefix Sum)
    - [ ]  Binary Indexed Tree (Prefix Sum Implementation)
    - [ ]  Binary Indexed Tree (Update Operation)
    - [ ]  Binary Indexed Tree (Construction)
    - [ ]  Range Min Max Queries
    - [ ]  Range GCD Queries
    - [ ]  Range Longest Correct Bracket Subsequence Queries
    - [ ]  Range Sum Queries
    - [ ]  Largest Sum Contiguous Subarray in Range
    - [ ]  Range LCM Queries
- [ ]  **Disjoint set**
    - [ ]  Disjoint Set Introduction
    - [ ]  Find and Union Operations on Disjoint Sets
    - [ ]  Union by Rank
    - [ ]  Path Compression
    - [ ]  Kruskal's Algorithm
    - [ ]  Union-Find
    - [ ]  Detect Cycle using DSU
    - [ ]  Number of Connected Components
    - [ ]  Minimum Spanning Tree using Kruskal

**Projects**

- [ ]  Sudoku solver
- [ ]  Shortest path finder
- [ ]  Tic Tac Toe
- [ ]  N Queens Visualizer
- [ ]  Binary tree visualizer